## Thread 기본 개념

# 운영체제
  * 운영체제(Operating System)
        : 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는
          여러 프로그램의 모임, 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어임. 
		  % 운영체제 평가 기준
		  처리능력(Throughput): 일정 시간 내에 시스템이 처리하는 일의 양
          반환시간(Turn Around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
          사용가능도(Availability): 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
          신뢰도(Reliabilty): 시스템이 주어진 문제를 정확하게 해결하는 정도
		  % 기능
		  프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리합니다.
		  자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공합니다.
          사용자와 시스템간의 편리한 인터페이스를 제공합니다.
          시스템의 각종 하드웨어와 네트워크를 관리, 제어합니다.
          데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공합니다.
          시스템의 오류를 검사하고 복구합니다.
          자원 보호 기능을 제공합니다.
          입 출력에 대한 보조 기능을 제공합니다.
          가상 계산기 능력을 제공합니다.
		  프로세스 관리 : 프로세스 스케쥴링 및 동기화 관리 담당
		             프로세스 생성과 제거, 시작과 정지, 메시지 전달 등의 기능 담당
		  기억장치 관리 : 프로세스에게 메모리 할당 및 회수 관리 담당
		  주변장치 관리 : 입출력 장치 스케줄링 및 전반적인 관리 담당
		  파일 관리 : 파일의 생성과 삭제, 변경, 유지 등의 관리 담당
		  멀티 테스킹(multi-tasking) : 멀티 프로세스 운영체제에서 하나의 CPU가 복수의 프로세스를 번갈아가면서 실행하기 위해서 스케쥴링이 필요하다
               1. Non-Preemptive OS
                  비선점형 OS는 현재 실행 중인 프로세스보다 높은 우선순위를 가지는 프로세스가 실행된다고 해도 실행 대상을
                  바로 변경하지 않는다. 현재 실행 중인 프로세스가 명시적으로 CPU를 양보할 때까지 혹은I/O작업 등으로
                  블로킹 상태가 될 때까지 기다려야한다.
				  1-1. First Come First Served
                       먼저 CPU를 사용하기 위해 도착한 프로세스를 먼저 처리해주는 방식
				  1-2. Round Robin 
                       선입선출 보완. CPU를 한번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다. 
               2. Preemptive(Priority) OS
                  선점형 OS는 실행 중인 프로세스보다 높은 우선 순위의 프로세스가 실행되면, 스케쥴러에 의해 실행 순서가 적극
                  조정되는 OS를 말한다. 스케쥴링이 복잡하다
		  메모리 관리 : 고정 분할(Fixed partion)
		            물리적 멜모리를 몇 개의 영구적인 분할로 나눈다. 나뉜 가각의 분할에는 하나의 프로그램이 적재됨.
					분할의 크기보다 큰 프로그램은 적재가 불가능하다. 비효율적
					가변 분할(variable partion)
					매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식. 분할의 큰 프로그램의 실행이 제한되는 문제는
					없다. 그러나 물리적 메모리 크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.
					가상 메모리(virtual memory)
					실행될수있는 프로그램의 크기는 가상 메몸리의 크기에 의해 결정. os는 물리적 주소와 가상 메모리에 주소를 매핑하여
					관리한다.실행되지 않는 부분의 프로그램은 보조디스크에 두었다가 필요할때 메모리에 적재하는 방식
		  
		  
 * 커널(Kernel)
        : 소프트웨어인 운영체제가 컴퓨터 시스템에 수행되기 위해 메모리에 프로그램이 로드되어 있어야한다. BUT 규모가 큰 운영체제가
		  모두 올라간다면 한정된 메모리 공간의 낭비가 된다. 따라서 항상 필요한 부분만 메모리에 로드하여 사용하게 된다
		  이때 메모리에 상주하는 운영체제의 부분을 커널이라고 한다.운영체제의 핵심적인 부분이라고 할수 있다
# 프로그램(Program)
  
  어떤 작업을 위해 실행할 수 있는 파일
  멀티 프로그래밍: 다수의 프로세스를 메모리에 적재하여 프로세스를 번갈아가면서 처리하는것
  
# 프로세스(Process)
 
 사용자가 작성한 프로그램이 운영체제에 의해 독립된 메모리 영역(Code,Data,Stack,Heap)과
 시스템 자원(CPU 시간,주소영역)을 할당받아 실행 중인 독립적인 개체
 
 특징 : 각 프로세스는 별도의 주소 영역에서 실행되므로 서로 다른 프로세스의 변수나 자료구조에 접근 불가능 
      다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC,inter-process communication)을 사용해야함
	  ex) 파이프,파일,소켓을 이용
 
 멀티프로세싱 : 다수의 프로세서(cpu)가 자원을 공유하면서 다수의 프로세스를 동시에 처리, 별개의 메모리를 차지
            장점: 여개의 프로세스 중 하나의 프로세스에서 문제가 발생하면 그 프로세서만 죽고 다른 프로세서에 영향을 주지 않는다
            단점: Context Switching과정에서 캐쉬에 있는 모든 데이터를 리셋하고 복구하면서 오버헤드 발생
			     프로세스 사이의 통신 기법의 어려움           				  
				
 구성 : 프로그램에 사용되는 데이터,메모리등의 자원들, 1개 이상의 스레드(메인 스레드 포함) 
  
 *Context Switching: CPU가 여러 프로세스를 돌아가면서 작업를 처리하는 과정,동작 중인 프로세스가 대기를 하면서 
                   해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 
				   이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.
 *Overhead: 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.
 *Code: 실행 파일을 구성하는 명령어(기계어)들이 올라가는 공간
 *Data: 전역 변수나 static 변수의 할당을 위해 존재하는 영역
 *Stack: 지역 변수 할당, 함수의 매개변수, 함수 반환 주소
 *Heap: 동적으로 할당되는 메모리를 위한 공간
               
# 스레드(Thread)
 
 프로세스가 생성되면 CPU 스케줄러는 프로세스가 해야 할 일을 CPU에 전달하고 실제 작업은 CPU가 수행함
 이때 CPU 스케줄러가 CPU에 전달하는 일 하나가 스레드이다.
 운영체제 입장에서 작업의 단위는 프로세스, CPU입장에서 작업 단위는 스레드
 
 프로세스가 할당받은 자원을 이용하는 실행의 단위

 
 구성 : 프로세스 내에서 개별 스택,레지스터 영역를 따로 할당
 
 특징 : 모든 프로세스에 한 개 이상의 스레드 존재, 프로세스의 내에 heap,static,code영역 공유하여 한 스레드가 자원을
       변경하면 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다. 
        
 멀티스레드 프로세스(Multi-Threaded Process): 두 개 이상의 스레드를 가지는 프로세스 
        장점: 시스템 자원 효율성 증가(자원을 할당하는 프로세서 콜이 줄어듬,오버헤드 감소)
		    시스템 처리량 증가, 처리비용 감소,프로그램 응답 시간 단축(스레드간 Stack영역뺴고 공유하므로 데이터 주고받는게 간단)
			여러개의 CPU일 경우 각각의  CPU가 스레드를 하나씩 담당하는 방법으로 속도 향상가능
		단점 : 하나의 스레드가 문제가 발생하면 전체 프로세스가 영향을 받는다.
		      자원 공유 문제(동기화 문제)
		         ex) 두 스레드가 공유 변수i를 1증가시는 명령을 경우에 공유되는 i의 값을 레지스터에 저장 
				 >> 레지스터의 값을 1증가 >> 변수 i에 저장 >> i=2 or i=1이 될수 있다 
				 >> 스레드의 실행조건에 따라 다르므로 문제 >> 경쟁조건
		         >>세마포어 방법으로 공유 데이터에 접근하는 스레드의 개수를 한개 이하로 유지하므로써 해결
			  다른 프로세서에서 스레드를 제어하는게 불가능
			  디버깅이 까다로워 주의 깊은 설계가 필요하다
			  
*&* 직관적 비유 >> 오늘 점심 만들기(프로그램), 파스타 만들기(프로세스), 스테이크 만들기(프로세스),
               파스타 만들기에서 육수만들기(스레드1 채소썰기(채소),국물우려내기(채소)),면 삶기(스레드2)
https://goodmilktea.tistory.com/24?category=816729
#스레드의 종류

사용자 수준 스레드(User-Level Thread)
 사용자영역의 라이브러리를 통해 구현함,쓰레드의 행위는 사용자영역에서 하므로 커널이 스레드의 존재를 모름.
 라이브러리는 스레드의 생성,종료 스레드 간의 메시지 전달, 스레드의 스케줄링과 컨텍스트 등의 정보를 보관한다.
 스레드의 교환에 커널이 개입X >> 사용자 역역으로 전환할 필요 없다. 커널은 스레드가 아닌 프로세스를 한 단위로 인식하고 프로세서를 할당
 다수의 사용자 수준 스레드가 커널 수준 스레드 한 개에 매핑 되므로 다대일 스레드 매핑이라고 한다.
 장점: 동일한 메모리 영역에서 스레드가 생성 및 관리 >> 속도 빠름
      이식성이 높음: 커널에 독립적으로 스케줄링을 할 수 있어 모든 운영체제에 적용가능
	  오버헤드가 적음: 스케줄링이나 동기화를 하려고 커널을 호출하지 않으므로 커널 영역으로 전환하는 오버헤드가 줄어듬
	  유연한 스케줄링이 가능: 커널이 아닌 스레드 라이브러리에서 스레드 스케줄링을 제어하므로 응용프로그램에 맞게 스케줄링 가능
 단점:  시스템의 동시성 지원x: 스레드가 아닌 프로세스 단위로 프로세서를 할당하여 다중 처리 환경을 갖춰도 스레도 단위로 다중 처리를 하지못함
	  동일한 프로세스의 스레드 한개가 대기 상태과 되면 커널이 프로세스 내부의 스레드를 인식하지 못하여 해당 프로세스를 대기 상태로 전환시키므로
	  이 중 어떤 스레드도 실행하지 못한다.
	  스레드 간 보호 불가능: 스레드 간 보호에 커널의 보호 방법를 사용할 수 없음 스레드 라이브러릴에서 스레드 간 보호를 제공해야하므로 프로세스
	  수준에서 보호가 가능하다.

커널 수준 스레드(Kernel-Level Thread)
 운영체제(커널)가 지원하는 스레드 기능으로 구현, 커널이 스레드의 생성 및 스케쥴링 관리,한 프로세스에서 다수의 스레드가 프로세서를 할당받아'
 병행으로 수행하고 스레드 한 개가 대기 상태가 되면 커널이 개입하여 동일한 프로세스에 속한 다른 스레드로 교환이 가능하다.
 장점: 한 스레드가 시스템호출로 중단되더라도 커널은 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜줌
     다중처리기 환경에서 커널은 여려개의 스레드를 각각 다른 처리기에 할당 가능
 단점: 사용자 스레드에 비해 생성 및 관리하는 것이 느리다,커널이 전체 프로세스와 스레드 정보를 유지하여 오버헤드가 증가 

혼합형 스레드
 시스템 호출을 할 때 다른 스레드를 중단하는 다대일 매핑의 사용자 수준 스레드와 스레드 수 를 제한하는 일대일 매핑의 커널 수준 스레드의
 문제를 극복하는 방법. 사용자 수준 스레드는 커널 수준 스레드와 비슷한 경량 프로세스에 다대다 매핑, 경량 프로세스는 커널 수준 스레드와
 일대일로 매핑된다.
 
 
#스레드 데이터

스레드 기본 데이터 
 하나의 실행 흐름이므로 실행과 관련된 데이터 필요
 고유한 스레드ID, 프로그램 카운터, 레지스터 집합, 스택
 코드,데이터,파일등 기타 자원은 프로세스 내의 다른 스레드와 공유
 
스레드 특정 데이터(Thread-Specific Data,TSD) 
 하나의 스레드에만 연관된 데이터
 멀티스레드에서 모든 스레드는 프로세스의 데이터를 공유 특별한 경우 개별 스레드만의 자료 공간필요
 EX) 여려개의 트랜잭션을 스레드로 처리할 경우, 각각의 트랜잭션ID를 기억하고 있어야함 
 
## pthread.h

POSIX 스레드 : 유닉스 계열 시스템에서 병렬적으로 작동하는 소프트웨어의 작성을 위해서 제공되는 표준 API 
API(Application Programming Interface, 응용 프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

# void* : 어떤 변수의 주소값을 담을지 정해지지 않는 변수 = 어떤 포인터로도 변화가 가능한 만능 포인터
       *p 간접참조 불가능 >> *(int*p)로 캐스팅하여 접근 가능
# pthread_t : 스레드 자료형
# pthread_attr_t : 스레드 속성
# void* : 만능 포인터

# int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void*(start_routine)(void*), void*arg);
  스레드 생성
  *thread : thread를 구분하기 위하여 부여한는 ID의 포인터
  *attr : thread 생성 필요한 속성값의 포인터, 기본 스레드 속성 NULL
  void(*start_routine)(void*) : thread로 수행할 일을 정의할 function,인자 void* 반환형 void*
  *arg : stat_routinge함수에 넘겨주는 매개변수의 포인터
  성공 >> 0  , 실패 시 error number 반환

# int pthread_join(pthread_t thread, void **retval);
  스레드가 종료하기를 기다렸다가 스레드가 종료된 이후에 자원반납
  thread : 실행 종료를 기다릴 thread의 ID, 포인터 아님
  **thread_return : 실행이 끝난 함수의 반환값이 저장되는 포인터
  함수의 반환 값이 void*이므로 void*를 저장할 수 있는 위치(void**)를 넘겨줘야함
  리턴값 :  성공하면 0, 실패하면 에러코드 리턴

# void pthread_exit(void *retval);
  void *retval : 자신을 생성한 스레드에 retval인자를 반환하고 스레드 종료
  
# int pthread_detach(pthread_t th);
  일반적으로 pthread_create()를 사용하면 스레드가 종료되어도 사용했던 모든 자원이 해제되지 않는다
  pthread_join()을 사용하면 스레드가 종료될때 까지 기다렸다가 종료시점에 자원이 반납
  pthread_join()의 위의 기능을 한다.
  
# stdlib.h
exit(0): 에러없이 정상종료, exit(1): 에러코드반환, exit(자연수):에러코드반환
파일 입출력중인것을 저장+프로세스 종료
ruturn과의 차이는 문장을 실행하면서 종료

# void perror(const char* str);
 전역변수 errno의 값을 해석하여 시스템 오류 메세지를 표준 오류 출력스티림 stderr에 출력
  

https://ypangtrouble.tistory.com/entry/Pthread?category=672026
